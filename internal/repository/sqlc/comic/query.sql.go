// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package comic

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComicTracking = `-- name: CreateComicTracking :one
INSERT INTO comic_tracking (url, name, description, html, cron_spec)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, url, name, description, html, cron_spec, last_checked
`

type CreateComicTrackingParams struct {
	Url         string
	Name        pgtype.Text
	Description pgtype.Text
	Html        pgtype.Text
	CronSpec    pgtype.Text
}

func (q *Queries) CreateComicTracking(ctx context.Context, arg CreateComicTrackingParams) (ComicTracking, error) {
	row := q.db.QueryRow(ctx, createComicTracking,
		arg.Url,
		arg.Name,
		arg.Description,
		arg.Html,
		arg.CronSpec,
	)
	var i ComicTracking
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Description,
		&i.Html,
		&i.CronSpec,
		&i.LastChecked,
	)
	return i, err
}

const deleteComicTracking = `-- name: DeleteComicTracking :exec
DELETE FROM comic_tracking
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteComicTracking(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteComicTracking, id)
	return err
}

const getAllComicTrackings = `-- name: GetAllComicTrackings :many
SELECT id, url, name, description, html, last_checked, cron_spec
FROM comic_tracking
`

type GetAllComicTrackingsRow struct {
	ID          int32
	Url         string
	Name        pgtype.Text
	Description pgtype.Text
	Html        pgtype.Text
	LastChecked pgtype.Timestamp
	CronSpec    pgtype.Text
}

func (q *Queries) GetAllComicTrackings(ctx context.Context) ([]GetAllComicTrackingsRow, error) {
	rows, err := q.db.Query(ctx, getAllComicTrackings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllComicTrackingsRow
	for rows.Next() {
		var i GetAllComicTrackingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Description,
			&i.Html,
			&i.LastChecked,
			&i.CronSpec,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComicTrackingByID = `-- name: GetComicTrackingByID :one
SELECT id, url, name, description, html, last_checked, cron_spec
FROM comic_tracking
WHERE id = $1
`

type GetComicTrackingByIDRow struct {
	ID          int32
	Url         string
	Name        pgtype.Text
	Description pgtype.Text
	Html        pgtype.Text
	LastChecked pgtype.Timestamp
	CronSpec    pgtype.Text
}

func (q *Queries) GetComicTrackingByID(ctx context.Context, id int32) (GetComicTrackingByIDRow, error) {
	row := q.db.QueryRow(ctx, getComicTrackingByID, id)
	var i GetComicTrackingByIDRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Description,
		&i.Html,
		&i.LastChecked,
		&i.CronSpec,
	)
	return i, err
}

const getComicTrackingsList = `-- name: GetComicTrackingsList :many
SELECT id, url, name, description, html, last_checked, cron_spec
FROM comic_tracking
ORDER BY last_checked DESC
LIMIT $1 OFFSET $2
`

type GetComicTrackingsListParams struct {
	Limit  int32
	Offset int32
}

type GetComicTrackingsListRow struct {
	ID          int32
	Url         string
	Name        pgtype.Text
	Description pgtype.Text
	Html        pgtype.Text
	LastChecked pgtype.Timestamp
	CronSpec    pgtype.Text
}

func (q *Queries) GetComicTrackingsList(ctx context.Context, arg GetComicTrackingsListParams) ([]GetComicTrackingsListRow, error) {
	rows, err := q.db.Query(ctx, getComicTrackingsList, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComicTrackingsListRow
	for rows.Next() {
		var i GetComicTrackingsListRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Description,
			&i.Html,
			&i.LastChecked,
			&i.CronSpec,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComicTracking = `-- name: UpdateComicTracking :exec
UPDATE comic_tracking
SET url = $2,
    name = $3,
    description = $4,
    html = $5,
    last_checked = CURRENT_TIMESTAMP,
    cron_spec = $6
WHERE id = $1
RETURNING id, url, name, description, html, last_checked, cron_spec
`

type UpdateComicTrackingParams struct {
	ID          int32
	Url         string
	Name        pgtype.Text
	Description pgtype.Text
	Html        pgtype.Text
	CronSpec    pgtype.Text
}

func (q *Queries) UpdateComicTracking(ctx context.Context, arg UpdateComicTrackingParams) error {
	_, err := q.db.Exec(ctx, updateComicTracking,
		arg.ID,
		arg.Url,
		arg.Name,
		arg.Description,
		arg.Html,
		arg.CronSpec,
	)
	return err
}

const updateLastChecked = `-- name: UpdateLastChecked :exec
UPDATE comic_tracking
SET last_checked = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, last_checked
`

func (q *Queries) UpdateLastChecked(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLastChecked, id)
	return err
}
